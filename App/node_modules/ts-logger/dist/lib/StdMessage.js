"use strict";
var util_1 = require("util");
var path_1 = require("path");
var chalk = require('chalk');
var isError = require("lodash.iserror");
function getStackData(stackOffset) {
    stackOffset = stackOffset || 0;
    var stackReg = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i, stackReg2 = /at\s+()(.*):(\d*):(\d*)/i, stacklist = (new Error()).stack.split('\n'), s = stacklist[stackOffset] || stacklist[0], sp = stackReg.exec(s) || stackReg2.exec(s);
    var data = {
        method: "",
        fullPath: "",
        path: "",
        line: 0,
        pos: 0,
        file: "",
        stack: [],
    };
    if (sp && sp.length === 5) {
        data.method = sp[1];
        data.fullPath = sp[2];
        data.path = sp[2].replace(process.cwd() + "/", "");
        data.line = parseInt(sp[3]);
        data.pos = parseInt(sp[4]);
        data.file = path_1.basename(data.path);
        data.stack = stacklist;
    }
    return data;
}
var StdMessage = (function () {
    function StdMessage(type) {
        var messages = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            messages[_i - 1] = arguments[_i];
        }
        this.lines = [];
        this.type = type;
        this.date = new Date();
        this.messages = messages;
        this.errors = messages.filter(isError);
        this.std = (type === "ERROR" || type === "WARN") ? "err" : "out";
        this.stackData = getStackData(4);
        if (this.type !== "INFO") {
            messages.push("(`" + this.stackData.file + "` line:" + this.stackData.line + ")");
        }
    }
    StdMessage.prototype.toString = function () {
        var strMsg = [];
        var message = "";
        var inspectDepth = 10;
        this.messages.forEach(function (msg) {
            if (isError(msg)) {
                msg = chalk.red(util_1.inspect(msg, { depth: inspectDepth }));
            }
            else {
                // avoid inspecting strings so we dont lose format
                msg = (typeof msg === 'string') ? chalk.green(msg) : util_1.inspect(msg, { colors: chalk.supportsColor, depth: inspectDepth });
            }
            message = message.concat(msg).concat(" ");
        });
        message = message.concat("\n").replace(/'/g, "");
        if (this.errors.length) {
            this.errors.forEach(function (err) {
                message = message.concat(chalk.red(err.stack)).concat("\n");
            });
        }
        return this.date.toISOString() + " " + this.formatedType() + " " + message;
    };
    StdMessage.prototype.formatedType = function () {
        var formatedType;
        switch (this.type) {
            case "ERROR":
                formatedType = chalk.red(this.type);
                break;
            case "WARN":
                formatedType = chalk.yellow(this.type);
                break;
            case "INFO":
                formatedType = chalk.blue(this.type);
                break;
            case "LOG":
                formatedType = chalk.cyan(this.type);
                break;
            case "DEBUG":
                formatedType = chalk.magenta(this.type);
                break;
            case "SILLY":
                formatedType = chalk.gray(this.type);
                break;
            default:
                formatedType = this.type;
                break;
        }
        return formatedType.concat(":");
    };
    return StdMessage;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StdMessage;
